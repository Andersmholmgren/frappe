{"name":"Frappe","tagline":"A Dart package for functional reactive programming","body":"# Frappé\r\n\r\nA mildly [Bacon.js](http://baconjs.github.io/) inspired Dart package that aims to make functional reactive programming (FRP) easier in Dart. Frappé extends the behavior of Dart's streams, and introduces new concepts like properties and reactables.\r\n\r\nYou can explore the full API here: http://www.dartdocs.org/documentation/frappe/latest.\r\n\r\n## Why Frappé?\r\nFunctional reactive programming allows you to declaratively define behaviors for user actions. FRP makes it clearer to define behaviors such as, \"when a user performs A, do X and Y, then finish with Z.\"\r\n\r\nTo illustrate this, let's write an autocomplete widget with Frappé. After 250ms that a user inputs a character, a query is performed that suggests a list of movies that most closely matches the user's input. Because query results are asynchronous, we only want to show results from the last query.\r\n\r\n```dart\r\nvar searchInput = document.querySelector(\"#searchInput\");\r\n\r\nvar onInput = new EventStream(searchInput.onKeyUp)\r\n    .debounce(new Duration(milliseconds: 250)\r\n    .map((event) => event.target.value)\r\n    .distinct();\r\n    \r\nvar suggestions = onInput.flatMapLatest((input) => querySuggestions(input));\r\nvar isPending = onInput.isWaitingOn(suggestions);\r\n    \r\nFuture<List<String>> querySuggestions(String input) {\r\n  // Query some API that returns suggestions for 'input'\r\n}\r\n```\r\n\r\nFrappe also makes it easy to merge multiple stream. This is useful for performing an action that's triggered from multiple user behaviors. For instance to signal the close of an application:\r\n\r\n```dart\r\nvar onQuit = new EventStream(quitButton.onClick)\r\n    .merge(fileMenu.querySelector(\"quit\").onClick)\r\n    .merge(fatalErrors);\r\n    \r\nonQuit.listen((_) => closeApp());\r\n```\r\n\r\nIt's often useful to unsubscribe from a stream after a user performs some action. Frappe makes this easy with `takeUntil`. For instance, we can start listening to `onMouseMove` after `onMouseDown`, and unsubscribe after `onMouseUp`:\r\n\r\n```dart\r\nwindow.onMouseDown.forEach((mouseDown) {\r\n  var pen = new Pen(mouseDown.client);\r\n  new EventStream(window.onMouseMove).takeUntil(window.onMouseUp.first)\r\n      .forEach((mouseMove) => pen.drawTo(mouseMove.client))\r\n      .then((_) => pen.done())\r\n})\r\n```\r\n\r\n## Classes\r\n\r\n### Reactable\r\nThe `Reactable` class is what `EventStream` and `Property` extend from. It unifies the interface for classes that deliver events. At its heart, it defines a method `listen()`, which has the same behavior as Dart's `Stream.listen()`. In the same way that you'd listen to a Dart `Stream`, you'd use this method to subscribe to events from a `Reactable`, and use the returned `StreamSubscription` to unsubscribe from the stream.\r\n\r\n### EventStream\r\nAn `EventStream` is just like a `Stream` in Dart. It inherits the same interface as a `Stream`, but extends its functionality with methods like `merge`, `scan` and `takeUntil`. Since `EventStream` just extends from `Stream`, it's easy to compose streams from either Frappé or Dart.\r\n\r\n### Property\r\nProperties are similar to streams, but they remember their last value. This means that if a property has previously emitted the value of **x** to its subscribers, it will deliver this value to any of its new subscribers.\r\n\r\nFor instance, a property could be used to unify synchronous and asynchronous calls to get the window's current size:\r\n\r\n```dart\r\nMap innerSize() => {\"width\": window.innerWidth, \"height\": window.innerHeight};\r\n\r\nvar windowSize = new Property.fromStreamWithInitialValue(innerSize(),\r\n    window.onResize.map((_) => innerSize()));\r\n\r\nprint(innerSize()); // hypothetical window size {\"width\": 1024, \"height\": 768}\r\n\r\n// The first call to `listen` will deliver the property's current value. Since \r\n// this is the first subscriber, the value of {\"width\": 1024, \"height\": 768} will \r\n// be printed. Resizing the window will print out the window's new size.\r\nwindowSize.listen((size) => print(size));\r\n```\r\n\r\n#### Creating Properties\r\nThe `Property` class has constructors to create properties from a `Stream` or a `Future`.\r\n\r\n```dart\r\n// Create a property from a Dart Stream\r\nProperty.fromStream(stream);\r\n\r\n// Create a property from a Future.\r\nProperty.fromFuture(futureValue);\r\n```\r\n\r\nYou can also create a property that has a constant value.\r\n\r\n```dart\r\nvar constant = new Property.constant(5);\r\nconstant.listen((value) => print(value)); // 5\r\n```\r\n\r\nAn `EventStream` can also be converted into a `Property` with `EventStream.asProperty()`.\r\n\r\n##### Initial Values\r\nWhen creating a property from a stream or a future, the property will not have an initial value. Frappé includes additional constructors to create properties that have a starting value.\r\n\r\n```dart\r\n// Create a property from a stream with an initial value.\r\nProperty.fromStreamWithInitialValue(stream, initialValue);\r\n\r\n// Create a property from a Future with an initial value.\r\nProperty.fromFutureWithInitialValue(futureValue, initialValue);\r\n```\r\n\r\n#### Combining Properties\r\nProperties can be combined with each other to create derived values. These values will be recomputed whenever the value changes from which the property was derived.\r\n\r\nFrappé includes many built in combinators that you can use, such as `and`, `or`, `equals`, and also operator combinators like `+`, `-`, `>`, `<`. For instance in the following example, the enabled state of a login button is updated whenever the form's fields change. In order for the form to be valid, both the username and password fields must be populated.\r\n\r\n```dart\r\nbool isNotEmpty(String value) => value != null && value.isNotEmpty;\r\n\r\nvar isUsernamePresent = new Property\r\n    .fromStream(usernameField.onChange.map((_) => usernameField.value))\r\n    .map(isNotEmpty);\r\nvar isPasswordPresent = new Property\r\n    .fromStream(passwordField.onChange.map((_) => passwordField.value))\r\n    .map(isNotEmpty);\r\n    \r\nvar isFormValid = isUsernamePresent.and(isPasswordPresent);\r\nisFormValid.listen((isValid) => submitButton.disabled = !isValid);\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}